{
    "prompts": [
        "Here are some examples of how to use `helper.py`:\n```python\nfrom helper import *\n\n\"\"\"\nA pile of books on a desk\n\"\"\"\n\n\n@register()\ndef book(scale: P) -> Shape:\n    return primitive_call('cube', color=(.6, .3, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef books(width: float, length: float, book_height: float, num_books: int) -> Shape:\n    def loop_fn(i) -> Shape:\n        book_shape = library_call('book', scale=(width, book_height, length))\n        book_shape = transform_shape(book_shape, translation_matrix([np.random.uniform(-0.05, 0.05), i * book_height, np.random.uniform(-0.05, 0.05)]))  # FIRST translate\n        book_center = compute_shape_center(book_shape)  # must be computed AFTER transformation!!\n        return transform_shape(book_shape, rotation_matrix(np.random.uniform(-0.1, 0.1), direction=(0, 1, 0), point=book_center))  # THEN tilt\n\n    return loop(num_books, loop_fn)\n\n\n@register()\ndef desk(scale: P) -> Shape:\n    return primitive_call('cube', color=(.4, .2, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef desk_with_books() -> Shape:\n    desk_shape = library_call('desk', scale=(1, .1, .5))\n    books_shape = library_call('books', width=.21, length=.29, book_height=.05, num_books=3)\n    _, desk_top, _ = compute_shape_max(desk_shape)\n    _, books_bottom, _ = compute_shape_min(books_shape)\n    return concat_shapes(\n        desk_shape,\n        transform_shape(books_shape, translation_matrix((0, desk_top - books_bottom, 0)))  # stack books on top of desk\n    )\n\n```\nIMPORTANT: THE FUNCTIONS ABOVE ARE JUST EXAMPLES, YOU CANNOT USE THEM IN YOUR PROGRAM! \n\nNow, write a similar program for the given task:    \n```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n```\n",
        "Here are some examples of how to use `helper.py`:\n```python\nfrom helper import *\n\n\"\"\"\nA pile of books on a desk\n\"\"\"\n\n\n@register()\ndef book(scale: P) -> Shape:\n    return primitive_call('cube', color=(.6, .3, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef books(width: float, length: float, book_height: float, num_books: int) -> Shape:\n    def loop_fn(i) -> Shape:\n        book_shape = library_call('book', scale=(width, book_height, length))\n        book_shape = transform_shape(book_shape, translation_matrix([np.random.uniform(-0.05, 0.05), i * book_height, np.random.uniform(-0.05, 0.05)]))  # FIRST translate\n        book_center = compute_shape_center(book_shape)  # must be computed AFTER transformation!!\n        return transform_shape(book_shape, rotation_matrix(np.random.uniform(-0.1, 0.1), direction=(0, 1, 0), point=book_center))  # THEN tilt\n\n    return loop(num_books, loop_fn)\n\n\n@register()\ndef desk(scale: P) -> Shape:\n    return primitive_call('cube', color=(.4, .2, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef desk_with_books() -> Shape:\n    desk_shape = library_call('desk', scale=(1, .1, .5))\n    books_shape = library_call('books', width=.21, length=.29, book_height=.05, num_books=3)\n    _, desk_top, _ = compute_shape_max(desk_shape)\n    _, books_bottom, _ = compute_shape_min(books_shape)\n    return concat_shapes(\n        desk_shape,\n        transform_shape(books_shape, translation_matrix((0, desk_top - books_bottom, 0)))  # stack books on top of desk\n    )\n\n```\nIMPORTANT: THE FUNCTIONS ABOVE ARE JUST EXAMPLES, YOU CANNOT USE THEM IN YOUR PROGRAM! \n\nNow, write a similar program for the given task:    \n```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n```\n",
        "Here are some examples of how to use `helper.py`:\n```python\nfrom helper import *\n\n\"\"\"\nA pile of books on a desk\n\"\"\"\n\n\n@register()\ndef book(scale: P) -> Shape:\n    return primitive_call('cube', color=(.6, .3, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef books(width: float, length: float, book_height: float, num_books: int) -> Shape:\n    def loop_fn(i) -> Shape:\n        book_shape = library_call('book', scale=(width, book_height, length))\n        book_shape = transform_shape(book_shape, translation_matrix([np.random.uniform(-0.05, 0.05), i * book_height, np.random.uniform(-0.05, 0.05)]))  # FIRST translate\n        book_center = compute_shape_center(book_shape)  # must be computed AFTER transformation!!\n        return transform_shape(book_shape, rotation_matrix(np.random.uniform(-0.1, 0.1), direction=(0, 1, 0), point=book_center))  # THEN tilt\n\n    return loop(num_books, loop_fn)\n\n\n@register()\ndef desk(scale: P) -> Shape:\n    return primitive_call('cube', color=(.4, .2, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef desk_with_books() -> Shape:\n    desk_shape = library_call('desk', scale=(1, .1, .5))\n    books_shape = library_call('books', width=.21, length=.29, book_height=.05, num_books=3)\n    _, desk_top, _ = compute_shape_max(desk_shape)\n    _, books_bottom, _ = compute_shape_min(books_shape)\n    return concat_shapes(\n        desk_shape,\n        transform_shape(books_shape, translation_matrix((0, desk_top - books_bottom, 0)))  # stack books on top of desk\n    )\n\n```\nIMPORTANT: THE FUNCTIONS ABOVE ARE JUST EXAMPLES, YOU CANNOT USE THEM IN YOUR PROGRAM! \n\nNow, write a similar program for the given task:    \n```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n```\n",
        "Here are some examples of how to use `helper.py`:\n```python\nfrom helper import *\n\n\"\"\"\nA pile of books on a desk\n\"\"\"\n\n\n@register()\ndef book(scale: P) -> Shape:\n    return primitive_call('cube', color=(.6, .3, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef books(width: float, length: float, book_height: float, num_books: int) -> Shape:\n    def loop_fn(i) -> Shape:\n        book_shape = library_call('book', scale=(width, book_height, length))\n        book_shape = transform_shape(book_shape, translation_matrix([np.random.uniform(-0.05, 0.05), i * book_height, np.random.uniform(-0.05, 0.05)]))  # FIRST translate\n        book_center = compute_shape_center(book_shape)  # must be computed AFTER transformation!!\n        return transform_shape(book_shape, rotation_matrix(np.random.uniform(-0.1, 0.1), direction=(0, 1, 0), point=book_center))  # THEN tilt\n\n    return loop(num_books, loop_fn)\n\n\n@register()\ndef desk(scale: P) -> Shape:\n    return primitive_call('cube', color=(.4, .2, .1), shape_kwargs={'scale': scale})\n\n\n@register()\ndef desk_with_books() -> Shape:\n    desk_shape = library_call('desk', scale=(1, .1, .5))\n    books_shape = library_call('books', width=.21, length=.29, book_height=.05, num_books=3)\n    _, desk_top, _ = compute_shape_max(desk_shape)\n    _, books_bottom, _ = compute_shape_min(books_shape)\n    return concat_shapes(\n        desk_shape,\n        transform_shape(books_shape, translation_matrix((0, desk_top - books_bottom, 0)))  # stack books on top of desk\n    )\n\n```\nIMPORTANT: THE FUNCTIONS ABOVE ARE JUST EXAMPLES, YOU CANNOT USE THEM IN YOUR PROGRAM! \n\nNow, write a similar program for the given task:    \n```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n```\n"
    ],
    "completions": [
        [
            "```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n\n@register()\ndef chessboard(size: float, thickness: float) -> Shape:\n    \"\"\"\n    Creates a chessboard with alternating black and white squares.\n    \n    Args:\n        size: float - total size of the chessboard (8 squares x 8 squares)\n        thickness: float - thickness of the chessboard\n    \"\"\"\n    square_size = size / 8\n    shapes = []\n    \n    for i in range(8):\n        for j in range(8):\n            color = (0.9, 0.9, 0.9) if (i + j) % 2 == 0 else (0.1, 0.1, 0.1)\n            square = primitive_call(\n                'cube',\n                shape_kwargs={'scale': (square_size, thickness, square_size)},\n                color=color\n            )\n            x = -size/2 + square_size/2 + i * square_size\n            z = -size/2 + square_size/2 + j * square_size\n            square = transform_shape(square, translation_matrix((x, thickness/2, z)))\n            shapes.append(square)\n    \n    return concat_shapes(*shapes)\n\n@register()\ndef pawn(height: float, radius: float) -> Shape:\n    \"\"\"\n    Creates a pawn chess piece.\n    \n    Args:\n        height: float - total height of the pawn\n        radius: float - base radius of the pawn\n    \"\"\"\n    # Base\n    base_height = height * 0.3\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, base_height, 0)},\n        color=(0.8, 0.8, 0.8)\n    )\n    \n    # Middle\n    middle_height = height * 0.4\n    middle_radius = radius * 0.7\n    middle = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': middle_radius},\n        color=(0.8, 0.8, 0.8)\n    )\n    middle = transform_shape(middle, translation_matrix((0, base_height + middle_radius, 0)))\n    \n    # Top\n    top_height = height * 0.3\n    top_radius = radius * 0.4\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': top_radius},\n        color=(0.8, 0.8, 0.8)\n    )\n    top = transform_shape(top, translation_matrix((0, base_height + middle_height + top_radius, 0)))\n    \n    return concat_shapes(base, middle, top)\n\n@register()\ndef rook(height: float, radius: float) -> Shape:\n    \"\"\"\n    Creates a rook chess piece.\n    \n    Args:\n        height: float - total height of the rook\n        radius: float - base radius of the rook\n    \"\"\"\n    # Base\n    base_height = height * 0.2\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, base_height, 0)},\n        color=(0.2, 0.2, 0.2)\n    )\n    \n    # Body\n    body_height = height * 0.6\n    body = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*1.8, body_height, radius*1.8)},\n        color=(0.2, 0.2, 0.2)\n    )\n    body = transform_shape(body, translation_matrix((0, base_height + body_height/2, 0)))\n    \n    # Battlements\n    battlement_height = height * 0.2\n    battlement_radius = radius * 0.3\n    battlements = []\n    for i in range(4):\n        for j in range(4):\n            battlement = primitive_call(\n                'cylinder',\n                shape_kwargs={'radius': battlement_radius, 'p0': (0, 0, 0), 'p1': (0, battlement_height, 0)},\n                color=(0.2, 0.2, 0.2)\n            )\n            x = -radius*0.6 + i * (radius*1.2/3)\n            z = -radius*0.6 + j * (radius*1.2/3)\n            battlement = transform_shape(battlement, translation_matrix((x, base_height + body_height + battlement_height/2, z)))\n            battlements.append(battlement)\n    \n    return concat_shapes(base, body, *battlements)\n\n@register()\ndef chess_set(board_size: float, piece_height: float) -> Shape:\n    \"\"\"\n    Creates a complete chess set with board and pieces.\n    \n    Args:\n        board_size: float - size of the chessboard\n        piece_height: float - height of the pieces\n    \"\"\"\n    board = library_call('chessboard', size=board_size, thickness=0.1)\n    \n    # Calculate positions\n    square_size = board_size / 8\n    piece_radius = square_size * 0.4\n    \n    # Create white pieces\n    white_pieces = []\n    for i in range(8):\n        # Pawns\n        pawn_shape = library_call('pawn', height=piece_height, radius=piece_radius)\n        x = -board_size/2 + square_size/2 + i * square_size\n        z = -board_size/2 + square_size * 1.5\n        pawn_shape = transform_shape(pawn_shape, translation_matrix((x, 0.1 + piece_height/2, z)))\n        white_pieces.append(pawn_shape)\n    \n    # Create black pieces\n    black_pieces = []\n    for i in range(8):\n        # Pawns\n        pawn_shape = library_call('pawn', height=piece_height, radius=piece_radius)\n        x = -board_size/2 + square_size/2 + i * square_size\n        z = board_size/2 - square_size * 1.5\n        pawn_shape = transform_shape(pawn_shape, translation_matrix((x, 0.1 + piece_height/2, z)))\n        black_pieces.append(pawn_shape)\n    \n    return concat_shapes(board, *white_pieces, *black_pieces)\n```"
        ],
        [
            "```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n\n@register()\ndef chessboard(size: float, thickness: float) -> Shape:\n    \"\"\"\n    Creates a chessboard with alternating black and white squares.\n    \n    Args:\n        size: float - total size of the chessboard (8x8 squares)\n        thickness: float - thickness of the chessboard\n    \"\"\"\n    square_size = size / 8\n    shapes = []\n    for i in range(8):\n        for j in range(8):\n            color = (0.9, 0.9, 0.9) if (i + j) % 2 == 0 else (0.1, 0.1, 0.1)\n            square = primitive_call(\n                'cube',\n                shape_kwargs={'scale': (square_size, thickness, square_size)},\n                color=color\n            )\n            x = (i - 3.5) * square_size\n            z = (j - 3.5) * square_size\n            square = transform_shape(square, translation_matrix((x, thickness/2, z)))\n            shapes.append(square)\n    return concat_shapes(*shapes)\n\n@register()\ndef pawn(color: tuple[float, float, float], height: float, radius: float) -> Shape:\n    \"\"\"\n    Creates a pawn chess piece.\n    \n    Args:\n        color: tuple[float, float, float] - RGB color of the piece\n        height: float - total height of the pawn\n        radius: float - base radius of the pawn\n    \"\"\"\n    # Base cylinder\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.4, 0)},\n        color=color\n    )\n    # Middle sphere\n    middle = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.8},\n        color=color\n    )\n    middle = transform_shape(middle, translation_matrix((0, height*0.4, 0)))\n    # Top sphere\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.5},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.8, 0)))\n    return concat_shapes(base, middle, top)\n\n@register()\ndef rook(color: tuple[float, float, float], height: float, radius: float) -> Shape:\n    \"\"\"\n    Creates a rook chess piece.\n    \"\"\"\n    # Base\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.3, 0)},\n        color=color\n    )\n    # Middle\n    middle = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*1.8, height*0.2, radius*1.8)},\n        color=color\n    )\n    middle = transform_shape(middle, translation_matrix((0, height*0.4, 0)))\n    # Top\n    top = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius*0.8, 'p0': (0, height*0.5, 0), 'p1': (0, height, 0)},\n        color=color\n    )\n    return concat_shapes(base, middle, top)\n\n@register()\ndef chess_set(board_size: float) -> Shape:\n    \"\"\"\n    Creates a complete chess set with all pieces on a board.\n    \"\"\"\n    # Create board\n    board = library_call('chessboard', size=board_size, thickness=0.05)\n    \n    # Calculate piece positions\n    square_size = board_size / 8\n    piece_height = square_size * 0.8\n    piece_radius = square_size * 0.3\n    \n    # Create pieces\n    pieces = []\n    \n    # White pieces\n    white_color = (0.9, 0.9, 0.9)\n    for i in range(8):\n        # Pawns\n        pawn_piece = library_call('pawn', color=white_color, height=piece_height, radius=piece_radius)\n        x = (i - 3.5) * square_size\n        z = -3.5 * square_size\n        pawn_piece = transform_shape(pawn_piece, translation_matrix((x, 0.05 + piece_height/2, z)))\n        pieces.append(pawn_piece)\n    \n    # Black pieces\n    black_color = (0.1, 0.1, 0.1)\n    for i in range(8):\n        # Pawns\n        pawn_piece = library_call('pawn', color=black_color, height=piece_height, radius=piece_radius)\n        x = (i - 3.5) * square_size\n        z = 3.5 * square_size\n        pawn_piece = transform_shape(pawn_piece, translation_matrix((x, 0.05 + piece_height/2, z)))\n        pieces.append(pawn_piece)\n    \n    return concat_shapes(board, *pieces)\n```"
        ],
        [
            "```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n\n@register()\ndef chessboard(size: float, thickness: float) -> Shape:\n    \"\"\"Creates a chessboard with alternating black and white squares.\"\"\"\n    def create_square(x: float, z: float, color: tuple[float, float, float]) -> Shape:\n        square = primitive_call(\n            'cube',\n            shape_kwargs={'scale': (size/8, thickness, size/8)},\n            color=color\n        )\n        return transform_shape(square, translation_matrix((x, thickness/2, z)))\n    \n    squares = []\n    for i in range(8):\n        for j in range(8):\n            x = -size/2 + (i + 0.5) * size/8\n            z = -size/2 + (j + 0.5) * size/8\n            color = (1, 1, 1) if (i + j) % 2 == 0 else (0, 0, 0)\n            squares.append(create_square(x, z, color))\n    return concat_shapes(*squares)\n\n@register()\ndef pawn(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Creates a pawn piece with a base and a rounded top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.7, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.8},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.7 + radius*0.8, 0)))\n    return concat_shapes(base, top)\n\n@register()\ndef rook(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Creates a rook piece with a castle-like top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*1.6, height*0.4, radius*1.6)},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.6 + height*0.2, 0)))\n    return concat_shapes(base, top)\n\n@register()\ndef knight(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Creates a knight piece with a horse head shape (simplified).\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.5, 0)},\n        color=color\n    )\n    head = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*1.5, height*0.5, radius*0.8)},\n        color=color\n    )\n    head = transform_shape(head, translation_matrix((0, height*0.5 + height*0.25, 0)))\n    return concat_shapes(base, head)\n\n@register()\ndef bishop(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Creates a bishop piece with a pointed top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.6},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.6 + radius*1.2, 0)))\n    return concat_shapes(base, top)\n\n@register()\ndef queen(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Creates a queen piece with a crown-like top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    crown = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.8},\n        color=color\n    )\n    crown = transform_shape(crown, translation_matrix((0, height*0.6 + radius*0.8, 0)))\n    return concat_shapes(base, crown)\n\n@register()\ndef king(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Creates a king piece with a cross on top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    cross_vertical = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius*0.2, 'p0': (0, height*0.6, 0), 'p1': (0, height, 0)},\n        color=color\n    )\n    cross_horizontal = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius*0.2, 'p0': (-radius*0.5, height*0.8, 0), 'p1': (radius*0.5, height*0.8, 0)},\n        color=color\n    )\n    return concat_shapes(base, cross_vertical, cross_horizontal)\n\n@register()\ndef chess_set(board_size: float) -> Shape:\n    \"\"\"Creates a complete chess set with all pieces on a board.\"\"\"\n    board = library_call('chessboard', size=board_size, thickness=0.1)\n    square_size = board_size / 8\n    piece_height = square_size * 0.8\n    piece_radius = square_size * 0.3\n    \n    # Create white pieces\n    white_pieces = []\n    for i in range(8):\n        white_pieces.append(library_call('pawn', height=piece_height*0.7, radius=piece_radius*0.7, color=(1, 1, 1)))\n    \n    white_pieces.append(library_call('rook', height=piece_height, radius=piece_radius, color=(1, 1, 1)))\n    white_pieces.append(library_call('knight', height=piece_height, radius=piece_radius, color=(1, 1, 1)))\n    white_pieces.append(library_call('bishop', height=piece_height, radius=piece_radius, color=(1, 1, 1)))\n    white_pieces.append(library_call('queen', height=piece_height*1.2, radius=piece_radius, color=(1, 1, 1)))\n    white_pieces.append(library_call('king', height=piece_height*1.3, radius=piece_radius, color=(1, 1, 1)))\n    \n    # Create black pieces\n    black_pieces = []\n    for i in range(8):\n        black_pieces.append(library_call('pawn', height=piece_height*0.7, radius=piece_radius*0.7, color=(0.2, 0.2, 0.2)))\n    \n    black_pieces.append(library_call('rook', height=piece_height, radius=piece_radius, color=(0.2, 0.2, 0.2)))\n    black_pieces.append(library_call('knight', height=piece_height, radius=piece_radius, color=(0.2, 0.2, 0.2)))\n    black_pieces.append(library_call('bishop', height=piece_height, radius=piece_radius, color=(0.2, 0.2, 0.2)))\n    black_pieces.append(library_call('queen', height=piece_height*1.2, radius=piece_radius, color=(0.2, 0.2, 0.2)))\n    black_pieces.append(library_call('king', height=piece_height*1.3, radius=piece_radius, color=(0.2, 0.2, 0.2)))\n    \n    # Position white pieces (row 1 and 2)\n    for i, piece in enumerate(white_pieces[:8]):  # pawns\n        x = -board_size/2 + (i + 0.5) * square_size\n        z = -board_size/2 + 1.5 * square_size\n        white_pieces[i] = transform_shape(piece, translation_matrix((x, piece_height*0.35 + 0.1, z)))\n    \n    for i, piece in enumerate(white_pieces[8:], start=0):  # other pieces\n        x = -board_size/2 + (i + 0.5) * square_size\n        z = -board_size/2 + 0.5 * square_size\n        white_pieces[8+i] = transform_shape(piece, translation_matrix((x, piece_height*0.5 + 0.1, z)))\n    \n    # Position black pieces (row 7 and 8)\n    for i, piece in enumerate(black_pieces[:8]):  # pawns\n        x = -board_size/2 + (i + 0.5) * square_size\n        z = -board_size/2 + 6.5 * square_size\n        black_pieces[i] = transform_shape(piece, translation_matrix((x, piece_height*0.35 + 0.1, z)))\n    \n    for i, piece in enumerate(black_pieces[8:], start=0):  # other pieces\n        x = -board_size/2 + (i + 0.5) * square_size\n        z = -board_size/2 + 7.5 * square_size\n        black_pieces[8+i] = transform_shape(piece, translation_matrix((x, piece_height*0.5 + 0.1, z)))\n    \n    return concat_shapes(board, *white_pieces, *black_pieces)\n```"
        ],
        [
            "```python\nfrom helper import *\n\n\"\"\"\na chessboard with a full set of chess pieces\n\"\"\"\n\n@register()\ndef chessboard(size: float, thickness: float) -> Shape:\n    \"\"\"Create a chessboard with alternating black and white squares.\"\"\"\n    def create_square(x: float, z: float, color: tuple[float, float, float]) -> Shape:\n        square = primitive_call(\n            'cube',\n            shape_kwargs={'scale': (size/8, thickness, size/8)},\n            color=color\n        )\n        return transform_shape(square, translation_matrix((x, thickness/2, z)))\n    \n    squares = []\n    for i in range(8):\n        for j in range(8):\n            x = -size/2 + (i + 0.5) * size/8\n            z = -size/2 + (j + 0.5) * size/8\n            color = (0.9, 0.9, 0.9) if (i + j) % 2 == 0 else (0.1, 0.1, 0.1)\n            squares.append(create_square(x, z, color))\n    return concat_shapes(*squares)\n\n@register()\ndef pawn(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Create a pawn piece with a base and a rounded top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.7, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.8},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.7 + radius*0.8, 0)))\n    return concat_shapes(base, top)\n\n@register()\ndef rook(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Create a rook piece with a base and a crown-like top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*1.5, height*0.4, radius*1.5)},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.6 + height*0.2, 0))))\n    return concat_shapes(base, top)\n\n@register()\ndef knight(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Create a simplified knight piece with a base and a horse head shape.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.5, 0)},\n        color=color\n    )\n    head = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*1.2, height*0.5, radius*0.8)},\n        color=color\n    )\n    head = transform_shape(head, translation_matrix((0, height*0.5 + height*0.25, 0))))\n    return concat_shapes(base, head)\n\n@register()\ndef bishop(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Create a bishop piece with a base and a pointed top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.6},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.6 + radius*0.6, 0))))\n    return concat_shapes(base, top)\n\n@register()\ndef queen(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Create a queen piece with a base and a crown-like top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'sphere',\n        shape_kwargs={'radius': radius*0.8},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.6 + radius*0.8, 0))))\n    return concat_shapes(base, top)\n\n@register()\ndef king(height: float, radius: float, color: tuple[float, float, float]) -> Shape:\n    \"\"\"Create a king piece with a base and a cross-like top.\"\"\"\n    base = primitive_call(\n        'cylinder',\n        shape_kwargs={'radius': radius, 'p0': (0, 0, 0), 'p1': (0, height*0.6, 0)},\n        color=color\n    )\n    top = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*0.3, height*0.4, radius*0.3)},\n        color=color\n    )\n    top = transform_shape(top, translation_matrix((0, height*0.6 + height*0.2, 0))))\n    cross = primitive_call(\n        'cube',\n        shape_kwargs={'scale': (radius*0.8, radius*0.2, radius*0.2)},\n        color=color\n    )\n    cross = transform_shape(cross, translation_matrix((0, height*0.6 + height*0.4, 0))))\n    return concat_shapes(base, top, cross)\n\n@register()\ndef chess_set() -> Shape:\n    \"\"\"Create a full chess set with all pieces on a chessboard.\"\"\"\n    board = library_call('chessboard', size=1.0, thickness=0.05)\n    pieces = []\n    \n    # Create white pieces\n    white_color = (0.9, 0.9, 0.9)\n    black_color = (0.1, 0.1, 0.1)\n    piece_height = 0.1\n    piece_radius = 0.04\n    \n    # Place pawns\n    for i in range(8):\n        pawn_shape = library_call('pawn', height=piece_height, radius=piece_radius, color=white_color)\n        x = -0.35 + i * 0.1\n        z = -0.25\n        pawn_shape = transform_shape(pawn_shape, translation_matrix((x, 0.05 + piece_height/2, z))))\n        pieces.append(pawn_shape)\n    \n    # Place rooks\n    for i in [0, 7]:\n        rook_shape = library_call('rook', height=piece_height*1.2, radius=piece_radius*1.1, color=white_color)\n        x = -0.35 + i * 0.1\n        z = -0.35\n        rook_shape = transform_shape(rook_shape, translation_matrix((x, 0.05 + piece_height*1.2/2, z))))\n        pieces.append(rook_shape)\n    \n    # Place knights\n    for i in [1, 6]:\n        knight_shape = library_call('knight', height=piece_height*1.1, radius=piece_radius, color=white_color)\n        x = -0.35 + i * 0.1\n        z = -0.35\n        knight_shape = transform_shape(knight_shape, translation_matrix((x, 0.05 + piece_height*1.1/2, z))))\n        pieces.append(knight_shape)\n    \n    # Place bishops\n    for i in [2, 5]:\n        bishop_shape = library_call('bishop', height=piece_height*1.1, radius=piece_radius, color=white_color)\n        x = -0.35 + i * 0.1\n        z = -0.35\n        bishop_shape = transform_shape(bishop_shape, translation_matrix((x, 0.05 + piece_height*1.1/2, z))))\n        pieces.append(bishop_shape)\n    \n    # Place queen\n    queen_shape = library_call('queen', height=piece_height*1.3, radius=piece_radius, color=white_color)\n    queen_shape = transform_shape(queen_shape, translation_matrix((-0.35 + 3 * 0.1, 0.05 + piece_height*1.3/2, -0.35))))\n    pieces.append(queen_shape)\n    \n    # Place king\n    king_shape = library_call('king', height=piece_height*1.4, radius=piece_radius, color=white_color)\n    king_shape = transform_shape(king_shape, translation_matrix((-0.35 + 4 * 0.1, 0.05 + piece_height*1.4/2, -0.35))))\n    pieces.append(king_shape)\n    \n    # Create black pieces (mirrored)\n    for piece in pieces[:]:\n        black_piece = transform_shape(piece, reflection_matrix((0, 0, 0), (0, 1, 0)))\n        black_piece = transform_shape(black_piece, scale_matrix(1.0, (0, 0, 0)))\n        black_piece = transform_shape(black_piece, translation_matrix((0, 0, 0.5)))\n        pieces.append(black_piece)\n    \n    return concat_shapes(board, *pieces)\n```"
        ]
    ]
}